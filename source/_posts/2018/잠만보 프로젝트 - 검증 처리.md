---
title: 잠만보 프로젝트 - Functional Endpoints 검증 처리
date: 2018-11-18
categories: [프로젝트, 잠만보]
---

## 개요  
이전 포스트에서 Functional Endpoints에 대한 검증 방식을 수동으로 선언해야하는 것을 알게 되었고 [`https://www.baeldung.com/spring-functional-endpoints-validation`](https://www.baeldung.com/spring-functional-endpoints-validation)에서의 힌트를 참고하여 검증 처리하는 방법을 구성하고자 합니다.  

#### 검증체 등록    
Spring WebFlux Validation 항목을 살펴보면 기본적으로 클래스패스에 Bean Validation이 있으면 `LocalValidatorFactoryBean`는 전역 검증체로 등록한다는 설명이 있습니다. 그런데 @Controller 메소드 인자에 @Valid 또는 @Validated와 함께 사용할 수 있다는 말 뿐이었습니다.  

아직은 Spring WebFlux가 Functional Endpoints에 대한 Validator 등록은 지원하지 않기 때문에 ServerRequest로 모델을 처리하는 과정에서 Validation을 진행해야 합니다.  

그래서 일단은 LocalValidatorFactoryBean을 Validator 빈으로 등록하겠습니다.  

```java  
@Configuration
public class WebFluxConfiguration implements WebFluxConfigurer {

    @Bean
    @Primary
    public Validator validator() {
        return new LocalValidatorFactoryBean();
    }
}
```

#### 빈 오브젝트에 Validation 지정하기  
그리고 간단하게 빈 오브젝트 클래스에 Validation 어노테이션들을 지정하겠습니다.

```java  
@Data
public class Account {
    private String id;
    @NotBlank(groups = CreateConstraint.class)
    private String name;
    @NotBlank(groups = CreateConstraint.class)
    @Length(min = 6, groups = CreateConstraint.class)
    private String password;
}
```

> validation 어노테이션의 groups에는 interface만 올 수 있는 것을 잊지마세요.

#### @Validated는 어떻게 처리해야 하는가  
@Controller의 메소드에 지정하는 @Validated처럼 모델에 대한 Validation Group을 어떻게 지정해야 할까요?

https://www.baeldung.com/spring-functional-endpoints-validation 의 4. Support to Bean Validation API Annotations을 보면 빈으로 등록된 Validator
를 사용하여 검증을 하지만 그룹 지정에 대해서는 힌트가 없었습니다. 그래서 [@Validated](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/validation/annotation/Validated.html)가 무엇으로 처리되는지 찾아보았습니다.  

##### @Validated
> Can be used e.g. with Spring MVC handler methods arguments. Supported through `SmartValidator`'s validation hint concept, with validation group classes acting as hint objects.  

## Validation Handler  
관련 포스트를 참고하여 Validation Handler를 만드는데 대신에 Validator 인터페이스를 SmartValidator로 변환(LocalValidatorFactoryBean에 의해)해서 검증을 처리하도록 코드를 작성합니다.  

```java  
public class AbstractValidationHandler<T, U extends Validator> {
    private final Class<T> clazz;
    private final U validator;

    protected AbstractValidationHandler(Class<T> clazz, U validator) {
        this.clazz = clazz;
        this.validator = validator;
    }

    public final Mono<T> handle(final ServerRequest request, String message) {
        return handle(request, message, new Class[]{});
    }

    public final Mono<T> handle(final ServerRequest request, String message, Class<?>... groups) {
        return request.bodyToMono(clazz).flatMap(body -> {
            Errors errors = new BeanPropertyBindingResult(body, clazz.getName());
            SmartValidator validator = (SmartValidator) this.validator;
            validator.validate(body, errors, groups);

            if(errors != null && !errors.getAllErrors().isEmpty()) {
//              throw new javax.validation.ValidationException(errors.getAllErrors().toString());
                throw new ValidationException(message, errors);
            }

            return Mono.just(body);
        });
    }
}
```

#### XXXHandler
이제 서버의 요청과 응답을 처리하는 핸들러 클래스가 AbstractValidationHandler를 확장하도록 해야합니다.  

```java  
@Component
public class AccountHandler extends AbstractValidationHandler<Account, Validator> {
    private static final Logger LOG = LoggerFactory.getLogger(AccountHandler.class);

    @Autowired
    protected AccountHandler(Validator validator) {
        super(Account.class, validator);
    }

    public Mono<ServerResponse> signUp(ServerRequest request) {
        Mono<Account> account = handle(request, "Account validation error");
        return ServerResponse.ok()
                .contentType(MediaType.APPLICATION_JSON)
                .body(account, Account.class);
    }
}
```

핸들러가 @Component에 의해 빈으로 등록될 때 LocalValidatorFactoryBean에 의해 등록된 Validator를 사용하도록 하고 HandlerFunction에서 AbstractValidationHandler.handle을 호출하여 요청을 처리하도록 합니다. 위 코드에 따르면 요청 바디로 오는 값들이 바인딩 규칙을 따른다면 Account 오브젝트를 바디에 포함하여 응답할 것이고 규칙에 어긋난다면 ErrorAttributes 오브젝트를 다음과 같이 내려줄겁니다.  

```json
{
    "timestamp": 1542524386887,
    "path": "/signup",
    "status": 500,
    "error": "Internal Server Error",
    "message": "[Field error in object 'kr.kdev.app.bean.Account' on field 'name': rejected value []; codes [NotBlank.kr.kdev.app.bean.Account.name,NotBlank.name,NotBlank.java.lang.String,NotBlank]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [kr.kdev.app.bean.Account.name,name]; arguments []; default message [name]]; default message [반드시 값이 존재하고 공백 문자를 제외한 길이가 0보다 커야 합니다.]]",
    "exception": "javax.validation.ValidationException"
}
```

#### ValidationException을 위한 ErrorAttributes  
저는 javax.validation.ValidationException 대신에 개별적인 ValidationException을 만들어서 어떤 규칙에 어긋나는지에 대한 설명을 포함하도록 하겠습니다.  

```java  
@Component
public class ErrorAttributes extends DefaultErrorAttributes {

    @Override
    public Map<String, Object> getErrorAttributes(ServerRequest request, boolean includeStackTrace) {
        Map<String, Object> errorAttributes = super.getErrorAttributes(request, false);
        Throwable throwable = getError(request);
        errorAttributes.put("exception", throwable.getClass());

        if(throwable.getClass().isAssignableFrom(ValidationException.class)) {
            ValidationException exception = (ValidationException) throwable;
            errorAttributes.put("message", throwable.getMessage());
            List<Map> reasons = exception.getErrors().getAllErrors().stream().map(e->{
                Map<String, Object> errorMap = Maps.newHashMap();
                FieldError fieldError = (FieldError) e;
                errorMap.put("field", fieldError.getField());
                errorMap.put("reason", fieldError.getDefaultMessage());
                return errorMap;
            }).collect(Collectors.toList());

            errorAttributes.put("reasons", reasons);
        } else {
            errorAttributes.put("message", throwable.getMessage());
        }
        return errorAttributes;
    }
}
```

저는 오류가 발생한 필드와 사유만 보여주도록 하고 싶어 위와 같이 처리하였습니다. 여러분이 원하는 방식으로 만드시길 바랍니다.  

```json  
{
    "timestamp": 1542524413246,
    "path": "/signup",
    "status": 400,
    "error": "Bad Request",
    "message": "Account validation error",
    "exception": "kr.kdev.app.exception.ValidationException",
    "reasons": [
        {
            "reason": "반드시 값이 존재하고 공백 문자를 제외한 길이가 0보다 커야 합니다.",
            "field": "name"
        }
    ]
}
```

아쉽게도 @ModelAttribute와 같이 FormData나 Parameter에 대한 바인딩 검증 처리는 어떻게 해야할지는 좀더 연구해봐야겠습니다.  
다음 포스트에서는 무엇을 만들어야 할지 고민해보고 비동기를 지원하지 않는 RDB를 사용할지 NoSQL를 사용할지 정해야겠습니다.  

## 참고  
- [webflux-config-validation](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-config-validation)
- [spring-functional-endpoints-validation](https://www.baeldung.com/spring-functional-endpoints-validation)
- [validation-beanvalidation-spring-method](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#validation-beanvalidation-spring-method)  
