---
title: 잠만보 프로젝트 - 페이지 템플릿 및 세션 처리
date: 2018-11-24
categories: [프로젝트, 잠만보]
---

## 개요  
Spring WebFlux의 FunctionEndpoints가 간단해서 좋기는 한데 애노테이션을 활용하지 못한다는 단점이 큰 것 같아서 애노테이션 기반으로 진행하기로 하였습니다. 이번에는 애플리케이션에서 발생하는 각종 오류에 대해서 처리할 수 있도록 에러 페이지를 구성하려고 합니다.  

#### Spring WebFlux에서의 에러 처리  
이전 포스트인 Functional Endpoints의 요청부터 응답까지를 보셨다면 `WebFluxResponseStatusExceptionHandler`를 확장한 빈을 등록하여 에러를 처리한 것을 기억하실 것입니다. 애노테이션 기반이라면 `@ControllerAdvice`도 다시 사용할 수 있는데 굳이 그럴 필요가 없습니다!  

예를 들어, 다음과 같이 응답 코드에 따라 뷰를 지정하지 않아도 원하는 결과를 보여줄 수 있다는 것입니다.  
```java  
@ControllerAdvice
public abstract class AbstractController {

    @ResponseStatus(HttpStatus.FORBIDDEN)
    @ExceptionHandler(value = ForbiddenException.class)
    public Rendering handleUnAuthorizedException(ForbiddenException e) {
        Map<String, Object> model = Maps.newHashMap();
        model.put("exception", e.getClass());
        model.put("status", HttpStatus.FORBIDDEN);
        model.put("message", e.getMessage());
        return Rendering.view("403").model(model).build();
    }

    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    @ExceptionHandler(value = Exception.class)
    public Rendering handleInternalException(Exception e) {
        return Rendering.view("500").build();
    }

    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(value = BadRequestException.class)
    public Rendering handleBadRequestException(BadRequestException e) {
        return Rendering.view("400").build();
    }
}
```

#### 타임리프 템플릿으로 에러 페이지 구성하기  
[`Spring Boot Reference의 Webflux-error-handling-custom-error-pages`](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-webflux-error-handling-custom-error-pages) 항목을 보면 상태 코드에 따라 HTML 에러 페이지를 보여주고 싶다면 `/error` 폴더안에 파일을 추가하라고 합니다. 또한, 템플릿 엔진도 적용할 수 있고 파일명이 `4xx`와 같다면 4로 시작하는 모든 에러를 그 페이지로 처리할 수 있게 해준답니다.  

![](/images/snorlax-project/01.png)

그러면 에러 정보는 뭐로 표시하는지 궁금하시겠죠 `DefaultErrorAttributes` 기억하시나요? 에러 페이지 템플릿에서 이 애트리뷰트 값들을 사용할 수 있습니다.

마치 다음과 같이 말이에요  
```html  
<script type="text/javascript" th:inline="javascript">
  /*<![CDATA[*/
  Object.defineProperty(window, '$e', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: {
          exception: /*[[${exception}]]*/,
          message: /*[[${message}]]*/,
          reasons: JSON.parse(/*[[${T(kr.kdev.app.utils.JSONUtils).writeValueAsString(reasons)}]]*/),
          status: /*[[${status}]]*/
      }
  });
  Object.freeze(window.$e);
  /*]]>*/
</script>
```

#### Hazelcast를 이용한 세션 처리  
일반적으로 Redis를 이용한 세션 처리방법이 많은데 다들 MongoDB 또는 Hazelcast를 추천하기 때문에 Hazelcast로 세션을 처리하도록 설정해보겠습니다.  

[Spring Session 레퍼런스](https://docs.spring.io/spring-session/docs/current/reference/html5/#api-hazelcastsessionrepository)를 참고해서 다음과 같이 Hazelcast 인스턴스를 빈으로 등록하면 됩니다.  

```java  
@EnableHazelcastHttpSession(maxInactiveIntervalInSeconds=3600)
@Configuration
public class SessionConfiguration {
    private static Logger LOG = LoggerFactory.getLogger(SessionConfiguration.class);

    @Value("${spring.session.hazelcast.map-name}")
    String mapName;

    @Bean
    public HazelcastInstance hazelcastInstance() {
        Config config = new Config();

        MapAttributeConfig attributeConfig = new MapAttributeConfig()
                .setName(HazelcastSessionRepository.PRINCIPAL_NAME_ATTRIBUTE)
                .setExtractor(PrincipalNameExtractor.class.getName());

        config.getMapConfig(mapName)
                .addMapAttributeConfig(attributeConfig)
                .addMapIndexConfig(new MapIndexConfig(HazelcastSessionRepository.PRINCIPAL_NAME_ATTRIBUTE, false));

        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance(config);
        return hazelcastInstance;
    }

    // https://docs.spring.io/spring-session/docs/current/reference/html5/#api-hazelcastsessionrepository
    @Bean
    public HazelcastSessionRepository hazelcastSessionRepository() {
        HazelcastSessionRepository repository = new HazelcastSessionRepository(hazelcastInstance().getMap(mapName));
        return repository;
    }
}
```

다만, 우리는 Spring WebFlux 기반이기 때문에 일반적인 MapSessionRepository가 아닌 `ReactiveMapSessionRepository`를 빈으로 등록해야 합니다. 이 클래스는 키를 세션으로 갖고 값을 세션으로 갖는 맵에서 세션을 지속하는 것을 허용합니다. 또한, 요구에 따라 논 블로킹으로 구현된 분산 맵과 함께 사용할 수도 있습니다.  

```java  
@Configuration
public class SessionConfiguration {
    // ...
    // https://docs.spring.io/spring-session/docs/current/reference/html5/#api-reactivemapsessionrepository
    @Bean
    public ReactiveSessionRepository reactiveSessionRepository() {
        return new ReactiveMapSessionRepository(new ConcurrentHashMap<>());
    }
}
```

다음 포스트에서는 잠만보 프로젝트를 본격적으로 시작해보겠습니다.  

## 참고  
- [thymeleaf-tutorials-javascript-inlining](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#javascript-inlining)  
- [spring-session-hazelcast](https://docs.spring.io/spring-session/docs/current/reference/html5/#api-hazelcastsessionrepository)  
