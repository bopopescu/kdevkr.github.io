---
title: 잠만보 프로젝트 - 회원가입 기능 구현하기
date: 2018-12-08
categories: [프로젝트, 잠만보]
---

## 개요
회원가입 기능을 구현하기 위해서 JDBC 기반의 리파지토리 추상화를 제공하는 [Spring Data JDBC](https://docs.spring.io/spring-data/jdbc/docs/1.0.3.RELEASE/reference/html/#dependencies.spring-framework)를 사용합니다.

```groovy
dependencies {
    implementation('org.springframework.boot:spring-boot-starter-data-jdbc')
    implementation('org.postgresql:postgresql')
}
```

## 기본 리파지토리 인터페이스 정의  
Spring Data JDBC는 `Repository`와 함께 `CrudRepositry`, `PagingAndSortingRepository`를 추가적으로 제공합니다.

그런데 사용하지 않는 함수까지 노출되기 때문에 기본 리파지토리 인터페이스를 정의해서 사용하겠습니다.

```java
@NoRepositoryBean
public interface BasicRepository<T, ID> extends Repository<T, ID> {
    <S extends T> S save(S entity);
    Optional<T> findById(ID id);
    boolean existsById(ID id);
    long count();
    void delete(T entity);
    Iterable<T> findAll(Sort sort);
    Page<T> findAll(Pageable pageable);
}
```

위 예제처럼 `@NoRepositoryBean` 어노테이션을 인터페이스에 명시하면 런타임시점에 인스턴스를 생성하지 않습니다.

> 도메인별 리파지토리 인터페이스를 정의하고 싶다면 `@RepositoryDefinition` 어노테이션을 붙여 구현하세요

## 회원가입 기능 구현하기  
#### 사용자 계정 리파지토리 인터페이스
간단하게 프로바이더별 사용자 수를 구할 수 있는 쿼리 함수와 이메일을 중복 제거해서 사용자 수를 구하는 함수를 생각해보았습니다.

```java
@Repository
public interface AccountRepository extends BasicRepository<Account, String> {
    long countByProvider(String provider);
    long countDistinctByEmailExists();
}

.s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 38ms. Found 1 repository interfaces.
```

#### 사용자 관련 서비스 클래스  
리파지토리 인터페이스를 그대로 사용하지 말고 계정 관련 서비스 클래스를 중간에 두도록 하겠습니다.
```java
@Service
public class AccountService {

    private final AccountRepository accountRepository;
    private final MailService mailService;
    private final PasswordEncoder passwordEncoder;

    @Autowired
    public AccountService(AccountRepository accountRepository, MailService mailService, PasswordEncoder passwordEncoder) {
        this.accountRepository = accountRepository;
        this.mailService = mailService;
        this.passwordEncoder = passwordEncoder;
    }

    /**
     * 사용자 회원가입
     * @param account
     * @return 회원가입 여부
     */
    public boolean signUp(Account account) {
        if(accountRepository.existsById(account.getId())) {
            return false;
        }
        account.setPassword(passwordEncoder.encode(account.getPassword()));
        Account signUpAccount = accountRepository.save(account);

        try {
            MimeMessageHelper helper = mailService.build("회원가입 안내", new String[]{signUpAccount.getEmail()}, MimeMessageHelper.MULTIPART_MODE_NO);
            Map<String, Object> variables = Maps.newHashMap();
            variables.put("id", signUpAccount.getId());
            variables.put("name", signUpAccount.getName());
            variables.put("timestamp", System.currentTimeMillis());

            String template = mailService.getFreemarkerEmailTemplateBuilder().build("signup.html", variables);
            helper.setText(template, true);
            mailService.sendUsingJavaMailSender(helper);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return StringUtils.isNotBlank(signUpAccount.getId());
    }

    /**
     * 사용자 로그인
     * @param id 아이디
     * @param password 비밀번호
     * @return {@link Account}
     */
    public Account signIn(String id, String password) {
        Optional<Account> res = accountRepository.findById(id);
        if(res.isPresent()) {
            Account account = res.get();
            if(passwordEncoder.matches(password, account.getPassword())) {
                return account;
            } else {
                throw new BadRequestException("비밀번호가 일치하지 않습니다.");
            }
        }
        throw new BadRequestException("로그인 하는 과정에서 오류가 발생하였습니다.");
    }

    /**
     * 아이디 사용여부
     * @param id 아이디
     * @return 사용여부
     */
    public boolean existsById(String id) {
        return accountRepository.existsById(id);
    }

    /**
     * 아이디로 사용자 정보 가져오기
     * @param id 아이디
     * @return {@link Account}
     */
    public Account findById(String id) {
        return accountRepository.findById(id).orElse(null);
    }
}
```
아직까지는 프로바이더를 통해서 회원가입하는 경우를 고려하지 않았습니다. 다음 시간에는 `깃허브 계정을 연동하는 방식`을 알아보고 계정 도메인에 추가적으로 필요한 정보가 무었인지 확인해보도록 하죠

#### 회원가입 완료 메일 샘플
간단하게 회원가입이 완료되었다는 메일도 발송합시다.
```java
/**
 * 사용자 회원가입
 * @param account
 * @return 회원가입 여부
 */
public boolean signUp(Account account) {
    if(accountRepository.existsById(account.getId())) {
        return false;
    }
    account.setPassword(passwordEncoder.encode(account.getPassword()));
    Account signUpAccount = accountRepository.save(account);

    try {
        MimeMessageHelper helper = mailService.build("회원가입 안내", new String[]{signUpAccount.getEmail()}, MimeMessageHelper.MULTIPART_MODE_NO);
        Map<String, Object> variables = Maps.newHashMap();
        variables.put("id", signUpAccount.getId());
        variables.put("name", signUpAccount.getName());
        variables.put("timestamp", System.currentTimeMillis());

        String template = mailService.getFreemarkerEmailTemplateBuilder().build("signup.html", variables);
        helper.setText(template, true);
        mailService.sendUsingJavaMailSender(helper);
    } catch (Exception e) {
        e.printStackTrace();
    }

    return StringUtils.isNotBlank(signUpAccount.getId());
}
```

![](/images/snorlax-project/05.png)

이상으로 회원가입 기능 구현하기를 마치겠습니다. 다음 포스트에서는 깃허브 계정 연동을 지원할 수 있도록 고민해보겠습니다.

## 참고
- [Spring Data JDBC - Reference Documentation](https://docs.spring.io/spring-data/jdbc/docs/1.0.3.RELEASE/reference/html/#dependencies.spring-framework)  
